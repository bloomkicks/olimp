(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[396],{1926:function(i,e,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/algorithms",function(){return t(4462)}])},4192:function(i,e,t){"use strict";var n=t(5893),r=t(5861),l=t(7357);t(7294);let s=i=>{let{title:e,children:t,id:s="",sx:h}=i;return(0,n.jsxs)(l.Z,{component:"article",id:s,mb:"30px",px:3.5,minWidth:340,sx:{"& > div":{mt:"7px"},"& > .code":{mt:"13px",mb:"13px"},"& > h2":{mb:"16px"},...h||{}},children:[e&&(0,n.jsx)(r.Z,{variant:"h3",children:e}),t]})};e.Z=s},2895:function(i,e,t){"use strict";var n=t(5893),r=t(7357);t(7294);let l=i=>{let{children:e,type:t}=i,l="string"==typeof e&&(null==t?void 0:t.includes("list")),s=null;return l&&(s=e.split("=END=")),(0,n.jsx)(r.Z,{component:"ordered-list"===t?"ol":"bullet-list"===t?"ul":"div",sx:{"& a":{color:"primary.main",textDecoration:"underline"},pl:(null==t?void 0:t.includes("list"))?2.5:0,"& li":{mt:.75}},children:l?s.map((i,e,t)=>(0,n.jsx)(r.Z,{component:"li",children:i},"item"+e)):e})};e.Z=l},4462:function(i,e,t){"use strict";t.r(e),t.d(e,{default:function(){return o}});var n=t(5893),r=t(2895),l=t(4192),s=t(7357);let h=()=>(0,n.jsxs)(s.Z,{children:[(0,n.jsxs)(l.Z,{title:"ОСНОВНЫЕ УЧЕБНЫЕ РЕСУРСЫ",children:[(0,n.jsx)(r.Z,{children:"Теперь, разобравшись с Питоном, мы можем приступать к изучению алгоритмов и структур данных. Язык программирова ния можно представить как инструмент, а алгоритмы как чертеж, план решения, который мы воплощаем в реальность этим инструментом"}),(0,n.jsx)(r.Z,{children:"Без чертежа не выйдет ничего хорошего, поэтому нам важно тщательно изучить эту область. В этом нам помогут всемирно признанные книги:"}),(0,n.jsx)(r.Z,{children:"1. \xabГрокаем алгоритмы\xbb от Адитьи Бхагравой - отличная книга для новичков, просто и понятно обьясняющая нужные нам алгоритмы, структуры данных и концепции в программировании. Также, в качестве языка программирования в ней используется Питон, так что мы сможем попрактиковаться"}),(0,n.jsx)(r.Z,{children:"2. \xabАлгоритмы. Построение и анализ\xbb от Томаса Кортмэн и других - довольно тяжелая книга, тщательно покрывающая широкий диапазон важных для нас алгоритмов. После ее прочтения вы станите намного лучше разбираться в алгоритмах и сильно увеличите свои шансы на успех в олимпиаде"}),(0,n.jsx)(r.Z,{children:"Также хорошим помощником станет книга \xabОлимпиадное программирование\xbb от Антти Лааксонена. Помимо различных приемов проектирования алгоритмов в ней подробно описано, как готовиться к олимпиадам, какими качествами нужно обладать, чтобы добиться высоких результатов."})]}),(0,n.jsxs)(l.Z,{title:"1. ПОНЯТНИЕ АЛГОРИТМОВ И СТРУКТУР ДАННЫХ",id:"algorithms-introduction",children:[(0,n.jsx)(r.Z,{children:"Алгоритмы и структуры данных - важные понятия в вычислительных науках, помогающие эффективно решать задачи различного рода"}),(0,n.jsx)(r.Z,{children:"Алгоритм - это набор инструкций, разработанных для решения конкретной проблемы или выполнения определенной задачи. Алгоритмы можно представить как пошаговые процедуры, которые принимают входные данные и производят выходные. Они являются неотъемлемой частью многих компьютерных программ и используются для выполнения операций, таких как поиск, сортировка и анализ данных"}),(0,n.jsx)(r.Z,{children:"Структуры данных, с другой стороны, являются способом организации данных в памяти компьютера. Структуры данных могут быть полезны для оптимизации определенных операций, таких как поиск, сортировка и вставка или удаление данных. Некоторые примеры структур данных включают массивы, связные списки, деревья и графы, которые мы разберем чуть позже"}),(0,n.jsx)(r.Z,{children:"Алгоритмы и структуры данных составляют основу многих компьютерных программ и являются важными инструментами для решения сложных задач в областях, таких как математика, инженерия и наука"}),(0,n.jsxs)(l.Z,{title:"2. СЛОЖНОСТЬ АЛГОРИТМОВ",id:"big-o",children:[(0,n.jsx)(r.Z,{children:"Сложность алгоритма относится к тому, как эффективно алгоритм использует вычислительные ресурсы, такие как время и память, для решения проблемы. Обычно это измеряется в терминах временной сложности и пространственной сложности. Временная сложность - это количество времени, необходимое для завершения алгоритма, а пространственная сложность - это количество памяти, которое алгоритм использует."}),(0,n.jsx)(r.Z,{children:"Big O нотация - это способ выражения временной сложности алгоритма в виде функции размера его входных данных. Она используется для описания наихудшего сценария, или верхней границы, временной сложности алгоритма. Например, если алгоритм занимает 2n + 5 шагов для завершения, мы бы выразили его временную сложность в виде большой O-нотации как O(n), где n представляет размер входных данных."}),(0,n.jsx)(r.Z,{children:"Big O имеет различные общие классы временных сложностей, такие как O(1), O(log n), O(n), O(n log n), O(n^2), O(2^n) и O(n!). Эти классы отражают, как растет временная сложность алгоритма при увеличении размера входных данных. В целом, по мере роста размера входных данных мы хотим, чтобы временная сложность алгоритма росла медленнее всего, что означает, что мы хотим выбирать алгоритмы с меньшими классами временной сложности, когда это возможно."}),(0,n.jsx)(r.Z,{children:"В целом, понимание сложности алгоритма и Big O нотации является важным для проектирования и реализации эффективных алгоритмов, которые могут экономить время и вычислительные ресурсы при решении сложных задач."})]}),(0,n.jsx)(l.Z,{title:"3. ARRAY И LINKED LIST",id:"arrays",children:(0,n.jsx)(r.Z,{children:"1"})}),(0,n.jsxs)(l.Z,{title:"4. РЕКУРСИЯ",id:"recursion",children:[(0,n.jsx)(r.Z,{children:"Рекурсия - это концепция программирования, при которой функция вызывает саму себя повторно до тех пор, пока не достигнет базового случая, когда функция перестает вызывать себя и возвращает окончательный результат. Рекурсию можно определить как повторяющийся процесс, в котором проблема разбивается на более мелкие подпроблемы того же типа, пока они не станут достаточно маленькими для прямого решения."}),(0,n.jsx)(r.Z,{children:"Рабочий принцип рекурсии прост - функция вызывает саму себя с менее сложной проблемой, пока проблему нельзя решить без рекурсии. Рекурсия часто используется в алгоритмах, которым требуется повторное выполнение процесса с другим входом или набором входных данных каждый раз."}),(0,n.jsx)(r.Z,{children:"Существуют две основные части рекурсивной функции: базовый случай, который определяет условие остановки (когда функция больше не вызывает себя), и рекурсивный случай (где функция вызывает саму себя с обновленными входными параметрами)."}),(0,n.jsx)(r.Z,{children:"Рекурсия является мощным инструментом для решения сложных проблем, имеющих несколько шагов, где каждый шаг требует того же типа вычислений, что и предыдущий шаг. Она часто используется в структурах данных, таких как деревья и графы, где структура данных естественным образом рекурсивна."})]}),(0,n.jsxs)(l.Z,{title:"5. АЛГОРИТМЫ ПОИСКА",id:"searching",children:[(0,n.jsx)(r.Z,{children:"Алгоритмы поиска в массиве - это набор техник и методов, которые используются для поиска определенных элементов или значений в массиве или списке элементов. Существует несколько популярных алгоритмов поиска в массиве, которые обычно используются, включая линейный поиск, двоичный поиск, интерполяционный поиск и экспоненциальный поиск."}),(0,n.jsx)(r.Z,{children:"1. Линейный поиск: это простейший алгоритм поиска, который ищет каждый элемент массива или списка и сравнивает его с целевым элементом до тех пор, пока не будет найдено соответствие. Линейный поиск имеет временную сложность O(n), где n - размер массива."}),(0,n.jsx)(r.Z,{children:"2. Двоичный поиск: это более эффективный алгоритм, который требует, чтобы массив был отсортирован в порядке. Он начинает свой поиск целевого элемента, рассматривая среднюю точку массива, а затем устраняет половину элементов, сравнивая целевой элемент с серединой. Двоичный поиск имеет временную сложность O(log n), где n - размер массива."}),(0,n.jsx)(r.Z,{children:"3. Интерполяционный поиск: это еще один вариант двоичного поиска, который используется, когда элементы в массиве равномерно распределены. Он использует формулу для оценки местоположения целевого элемента в массиве, а затем выполняет двоичный поиск. Интерполяционный поиск имеет временную сложность O(log log n), что быстрее, чем двоичный поиск."}),(0,n.jsx)(r.Z,{children:"4. Экспоненциальный поиск: это гибридный алгоритм, который объединяет как линейный, так и двоичный поиск. Он начинает поиск, рассматривая первый элемент, а затем увеличивает интервал в степени двойки до тех пор, пока не будет найден целевой элемент. Экспоненциальный поиск имеет временную сложность O(log n), что также совпадает с двоичным поиском."}),(0,n.jsx)(r.Z,{children:"В целом, выбор конкретного алгоритма поиска в массиве зависит от размера массива, распределения элементов в массиве и количества времени, доступного для поиска."})]}),(0,n.jsx)(l.Z,{title:"6. АЛГОРИТМЫ СОРТИРОВКИ",id:"sorting",children:(0,n.jsx)(r.Z,{children:"1"})}),(0,n.jsx)(l.Z,{title:"7. QUEUE И STACK",id:"queues",children:(0,n.jsx)(r.Z,{children:"1"})}),(0,n.jsx)(l.Z,{title:"8. ЭВРИСТИЧЕСКИЕ МЕТОДЫ",id:"heuristic-methods",children:(0,n.jsx)(r.Z,{children:"1"})}),(0,n.jsx)(l.Z,{title:"9. ХЭШ-ТАБЛИЦЫ И ХЭШ-ФУНКЦИИ",id:"hashmap",children:(0,n.jsxs)(r.Z,{children:["Хеш-таблицы - это тип структуры данных, позволяющий эффективно хранить и извлекать пары ",'"ключ-значение"',". Они используют хеш-функцию для отображения каждого ключа в индекс массива, что позволяет мгновенно находить значения. Это делает хеш-таблицы полезными для задач, где важно быстрое время поиска, таких как кэширование, индексирование и операции с базами данных. Однако могут возникать коллизии, когда два разных ключа отображаются на один и тот же индекс, что требует дополнительных шагов для разрешения конфликтов. В целом, хеш-таблицы предоставляют мощный инструмент для организации и эффективного доступа к данным."]})}),(0,n.jsx)(l.Z,{title:"10. НЕВЗВЕШЕННЫЙ ГРАФ И АЛГОРИТМЫ ПОИСКА",id:"unweighted-graph",children:(0,n.jsx)(r.Z,{children:"1"})}),(0,n.jsx)(l.Z,{title:"11. ВЗВЕШЕННЫЙ ГРАФ И АЛГОРИТМЫ НАХОЖДЕНИЯ КРАТЧАЙШЕГО ПУТИ",id:"weighted-graph",children:(0,n.jsx)(r.Z,{children:"1"})}),(0,n.jsx)(l.Z,{title:"12. ДЕРЕВЬЯ И АЛГОРИТМЫ ДЛЯ РАБОТЫ С НИМИ",id:"trees",children:(0,n.jsx)(r.Z,{children:"1"})}),(0,n.jsx)(l.Z,{title:"13. ЖАДНЫЕ АЛГОРИТМЫ",id:"greedy-algorithms",children:(0,n.jsx)(r.Z,{children:"1"})}),(0,n.jsx)(l.Z,{title:"14. ДИНАМИЧЕСКОЕ ПРОГРАММИРОВАНИЕ",id:"dynamic-programming",children:(0,n.jsx)(r.Z,{children:"1"})})]})]});var d=t(702);let c=()=>(0,n.jsx)(d.Z,{heading:"ВАЖНЫЕ АЛГОРИТМЫ И СТРУКТУРЫ ДАННЫХ",descTitle:"Структуры данных и алгоритмы",description:"Знание алгоритмов и структур данных позволяет найти самый эффективный способ решения задачи",planTitle:"ПЛАН ОБУЧЕНИЯ",planPoints:[{title:"Понятие алгоритмов и структур данных",href:"#algorithms-introduction"},{title:"Сложность алгоритмов, Big O нотация",href:"#big-o"},{title:"Array и Linked List",href:"#arrays"},{title:"Рекурсия",href:"#recursion"},{title:"Алгоритмы поиска",href:"#searching"},{title:"Алгоритмы сортировки",href:"#sorting"},{title:"Queue и Stack",href:"#queues"},{title:"Эвристические методы",href:"#heuristic-methods"},{title:"Хэш-таблицы и хэш-функции",href:"#hashmap"},{title:"Невзвешенный граф и алгоритмы поиска",href:"#unweighted-graph"},{title:"Взвешенный граф и алгоритмы нахождения кратчайшего пути",href:"#weighted-graph"},{title:"Деревья и алгоритмы для работы с ними",href:"#trees"},{title:"Жадные алгоритмы",href:"#greedy-algorithms"},{title:"Динамическое программирование",href:"#dynamic-programming"}],illustration:{imgSrc:"./illustrations/algorithms/hero-illustration.png",width:412,height:261,alt:"",sx:{}}}),x=()=>(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(c,{}),(0,n.jsx)(h,{})]});var o=x}},function(i){i.O(0,[702,774,888,179],function(){return i(i.s=1926)}),_N_E=i.O()}]);